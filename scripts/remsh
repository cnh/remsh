#! /usr/bin/python
# This file is part of Remsh.
#
# Remsh is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Remsh is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Remsh.  If not, see <http://www.gnu.org/licenses/>.

import sys
import optparse

try: import readline
except: pass

from remsh.master import simpleslavecollection

def parse_options():
    parser = optparse.OptionParser()
    parser.add_option("-l", "--listen", dest="listen_port",
        help="Listen on TCP port PORT", metavar="PORT",
        type="int", default=None)

    global options, args
    (options, args) = parser.parse_args()

def get_slave():
    slave_collection=simpleslavecollection.SimpleSlaveCollection()
    if options.listen_port:
        from remsh.master.slavelistener import tcp
        print "waiting for slave to connect on port %d" % options.listen_port

        listener = tcp.TcpSlaveListener(slave_collection=slave_collection,
            port=options.listen_port)
        listener.start()
    else:
        from remsh.master.slavelistener import local
        print "starting a local slave"
        listener = local.LocalSlaveListener(slave_collection=slave_collection)
        listener.start_slave(".")
    return slave_collection.get_slave(block=True, filter=lambda sl : True)

def main():
    parse_options()

    sl = get_slave()

    while 1:
        try:
            cmd = raw_input("%s \x1b[33m$\x1b[0m " % sl.hostname).strip()
        except (EOFError, KeyboardInterrupt):
            break

        def stdout_cb(data):
            sys.stdout.write(data)
        def stderr_cb(data):
            # use ANSI color sequences to colorize stderr
            sys.stderr.write("\x1b[31m" + data + "\x1b[0m")
        resbox = sl.execute(args=['sh', '-c', cmd], stdout_cb=stdout_cb, stderr_cb=stderr_cb)
        print "$? =", resbox['result']

main()
